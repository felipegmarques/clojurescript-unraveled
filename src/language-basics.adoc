=== Primeiros passos com a sintaxe Lisp

Inventada por John Mccarthy em 1958, Lisp é uma das linguagens de progrmação
mais antigas que ainda são utilizadas. Ela possui várias outras derivações chamadas
de dialeto, sendo Clojure uma delas. É uma linguagem de programação escrita utilizando
suas próprias estrutura de dados - originalmente uma lista rodeada de parênteses -
mas Clojure evoluiu essa sintaxe para possuir mais estruturas de dados e ser mais
agradável de escrever.

Uma lista com uma função na primeira posição é utilizada para chamar uma função
em Clojure. No exemplo abaixo, nos aplicamos a função de adição a três argumentos.
Observe que diferente de outras linguagens, `+` não é um operado, mas uma função.
Lisp não possui operadores; somente funções.

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

No exemplo acima, estamos aplicando a função de adição `+` aos argumentos `1`, `2` e `3`.
Clojure permite vários caracteres não muito comuns como `?` e `-` em nome de símbolos,
o que a torna a leitura mais fácil:

[source, clojure]
----
(zero? 0)
;; => true
----

Para diferencial chamadas de funções de uma lista de itens, podemos usar uma aspa
o que evite que a lista seja calculada/avaliada, como no primeiro exemplo. Uma lista
com aspa no começo (_quoted list_) será tratada como dado ao invés de uma chamada de
função:

[source, clojure]
----
'(+ 1 2 3)
;; => (+ 1 2 3)
----

Clojure não usa somente listas para sua sintaxe. Cobriremos isso com mais detalhes mais
tarde, mas aqui está um exemplo de utilização de um vetor (rodeado por cochetes) para
definir uma relação entre nome e valor (_bidinng_) local:

[source, clojure]
----
(let [x 1
      y 2
      z 3]
  (+ x y z))
;; => 6
----

Essa é a sintaxe mínima que voc6e precisa saber para utilizar não só Clojure,
mas qualquer Lisp. Sendo escrita nas suas próprias estruturas de dados (aquela coisa de _homoiconicity_)
é uma propriedade muito poderosa, pois a sintaxe é uniforme e simples, além disso,
a geração de código através de xref:macros-section[macros] é mais simples que outras linguagens,
nos dando poder de ampliar a linguagem para se adequar às nossas necessidades.


=== Os tipos básicos

Clojure possui uma conjunto de tipos primitivos como maioria das linguagens.
Ele prove escalares que serão muito familiar para você como números, strings e
números de ponto flutuantes (_floats_). Além desses, ele provê alguns outros tipos
não muito comuns como símbolos, chaves, expressões regulares (_regex_), _vars_ e _atoms_.

_Clojure_ utiliza a linguagem hospedeira (_Java_), e quando possível, utiliza os
tipos fornecidos por ela. Por exemplo, números e strings são usados como providos
pelo linguagem e se comportam do mesmo jeito que se comportam em Java.

==== Números

Em _Clojure_, números incluem tanto inteiros quanto floating points (_float_).
Tenha em mente, que como uma linguagem hospedada na _JVM_, os tipos numéricos em _Clojure_
são os tipos nativos do Java como Integer e Long  por baixo dos panos,
mas tanbém provendo alguns outros tipos como BigInt.

Como em outras linguagens, números em _Clojure_ são representados da seguinte
maneira:

[source, clojure]
----
23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4
----


====  Chaves (_Keywords_)

Chaves em _Clojure_ são objetos que sempre são avalidados a eles mesmos. Eles
são usualmente usado em  <<maps-section,estruturas de dados do tipo mapa>> para representar
de maneira eficiente as chaves do mapa (ou dicionário).

[source, clojure]
----
:foobar
:2
:?
----

Como voc6e pode ver, as chaves são todas prefixadas com `:`, mas esse caracter é
apenas parte da sintaxe literal e não parte do nome do objeto.

Você também pode criar uma chave chamando a função `keyword`. Não se preocupe se você
não entende ou nada está claro no próximo exemplo, vamos discutir <<function-section,funções>>
em uma seção adiante.

[source, clojure]
----
(keyword "foo")
;; => :foo
----

===== Chaves qualificadas (ou com _Namespace_)

Quando prefixamos uma chave com `::`, essa chave passa a ser prefixada com o _namespace_ atual.
Note que chaves qualificadas afetam comparações de igualdade.

[source, clojure]
---
::foo
;; => :clojure.user/foo

(= ::foo :foo)
;; => false
---

Outra alternativa é incluir o _namespace_ na sintaxe literal da chava, isso é útil para criamos chaves qualificadas
para outro _namespace_:

[source, clojure]
---
:clojure.unraveled/foo
;; => :clojure.unraveled/foo
---

A função `keyword` também funciona como uma função que recebe 2 argumentos (_arity-2_) onde você
especifica o _namespace_ como primeiro argumento:

[source, clojure]
---
(keyword "clojure.unraveled" "foo")
;; => :clojure.unraveled/foo
---


==== Símbolos

Símbolos em _Clojure_ são muito parecidos com chaves (que agora você conhece0. Mas ao invés de
serem avaliados (_evaluated_) a eles mesmos, os símbolos são avaliados para outra coisa
a qual eles referem, que pode ser funções, variáveis, etc.

Símbolos começam sembre com um caractere não numério e pode conter caracteres alfa-numéricos
assim como *, +, !, -, -, ', e ? como:

[source, clojure]
----
sample-symbol
othersymbol
f1
my-special-swap!
----

Não se preocupe se você não entender isso de imediato, símbolos são usados praticamente
em todos os nossos outros exemplosl, o que te dá a oportunidade de aprender mais a medida
que avançamos.

==== Strings

Strings em _Clojure_ não são tão diferente de outras linguagens, então você já deve
saber suficiente sobre elas. Um único ponto interessante de mencionar é que elas
são imutáveis.

[source, clojure]
----
"An example of a string"
----

Um aspecto peculiar de strings em _Clojure_ devido a sintaxe de Lisp é que seja
strings de uma linha ou de várias linhas, elas possuem a mesma sintaxe.

[source, clojure]
----
"This is a multiline
      string in ClojureScript."
----

==== Caracteres

_Clojure_ também permite você escrever um único caractere usando a seguinte sintaxe
literal:

[source, clojure]
----
\a        ; "a" minúsculo
\newline  ; Caractere que indica uma nova linha
----


==== Coleções

O próximo grande passo em explicar a linguagem é explicar suas coleções e as
abstrações de coleções. _Clojure_ não é uma exceção a essa regra.

_Clojure_ vem com vários tipos de coleções. A principal diferenção do _Clojure_ para
outras linguagens é que suas coleções são persistentes e imutáveis.

Antes de entrarmos nesses conceitos (provavelmente) desconhecidos, vamos dar uma
visão geral das coleções existentes em _Clojure_.

===== Listas

Essa é uma coleção clássica em qualquer linguagem derivada do Lisp.
Listas são o tipo de coleção mais simples em _Clojure_. Elas podem conter itens
de qualquer tipo, incluindo outras coleções.

Listas em _Clojure_ são representadas por items envolvidos por parênteses:

[source, clojure]
----
'(1 2 3 4 5)
'(:foo :bar 2)
----

Como você pode ver, todos os exemplos de listas são prefixados com o caractere `'`.
Isso porque em linguagems derivadas do Lisp, listas são usadas para expressar
chamadas de funções (ou de macros). Nesse caso, o primeiro item deveria ser um
símbolo que é avaliado a alguma coisa que é chamável (ex: uma função), e o resto dos
elementos da lista serão argumentos da função. porém, nos exemplos anteriores, nos não
 queremos que o primeiro item da lista seja um símbolo, nos queremos que seja apenas
 uma lista de items.

O exemplo seguinte mostra a diferença entre listas com e sem uma aspa no começo:
[source, clojure]
----
(inc 1)
;; => 2

'(inc 1)
;; => (inc 1)
----

Como você pode ver, se evaluarmos `(inc 1)` sem prefixar com uma aspa `'`, ele
será transformado na função `inc` (de incrementar) e irá executar essa função com 1
como seu primeiro argumento, retornando o valor de 2.

Você pode também contruir uma lista com a função `list`:

[source, clojure]
----
(list 1 2 3 4 5)
;; => (1 2 3 4 5)

(list :foo :bar 2)
;; => (:foo :bar 2)
----

Listas tem a peculiaridade de ser muito eficiente se você acessar elas sequencialmente
ou os primeiros elementos, porém elas não são uma boa opção se você precisa acessar elementos
utilizando a posição (index) desses elementos.

===== Vetores

Como listas, vetores armazenam uma série de valores, mas nesse caso, de forma
mais eficiente para acesso através do index desses elementos. Não se preocupe, nas seções
seguintes vamos entrar nos detalhes, mas por hora, essa explicação é mais que suficiente.

Vetores usam cochetes como sintaxe literal, vamos ver alguns exemplos:

[source, clojure]
----
[:foo :bar]
[3 4 5 nil]
----

Como listas, vetores podem contem objetos de qualquer tipo, como mostrado no
exemplo anterior.

Você pode também explicitamente criar um vetor com a função `vector`, mas esse não é
o jeito mais comum de fazê-lo em _Clojure_.

[source, clojure]
----
(vector 1 2 3)
;; => [1 2 3]

(vector "blah" 3.5 nil)
;; => ["blah" 3.5 nil]
----


[[maps-section]]
===== Mapas (ou dicionários)

Mapas são coleções de abstrações que permite você armazenar pares de chave e valor.
Em outras linguages, esse tipo de estrutura são comumente conhecidas como has-map ou
dicionários. Mapas são literais em _Clojure_ e são escritos como pares entre chaves.

[source, clojure]
----
{:foo "bar", :baz 2}
{:alphabet [:a :b :c]}
----

NOTA: Podemos usar vírgulas para separar pares, mas elas são opcionais.
No geral, a formatação dos arquivos já favorece a leitura. Em _Clojure_, vírgulas
são como espaços.

Como vetores, cada item em um mapa literal é evaluado antes que seu resultado seja
armazenado no map, mas a ordem de resolução não é garantida.

===== Conjuntos

E finalmente, *sets* (ou conjuntos).

Conjuntos armazenam zero ou mais itens únicos de forma não ordenada. Como mapas,
eles  possuem chaves como sintaxe litera, com a diferença de serem prefixados com `#`.
Você também pode usar a função `set` para converter  uma coleção em um set:

[source, clojure]
----
#{1 2 3 :foo :bar}
;; => #{1 :bar 3 :foo 2}
(set [1 2 1 3 1 4 1 5])
;; => #{1 2 3 4 5}
----

Nas seções seguintes, vamos explorar a fundo conjuntos e outras coleções que vimos
nessa seção. 

=== Vars

_Clojure_ é uma linguagem funcional que foca principalmente em imutabilidade.
Por cause disso, ela não tem o conceito de variáveis como estamos acostumados
em outras linguagens. A analogia mais próxima de vars são as variáveis que
definimos na álgebra; quando dizemos `x = 6` na matemática, estamos dizendo que queremos
que o símbolo `x` tenha, ou represente, o número seis.

Em _Clojure_, vars são representadas por símbolos e armazenam um único valor
junto com alguns meta-dados.

Você pode definir uma var utilizando a forma especial `def`:

[source, clojure]
----
(def x 22)
(def y [1 2 3])
----

Vars são tempre top level em um _namespace_(<<namespace-section,which we will
explain later>>). Se você usar `dev` em uma chamada de função, aquela var será definida
no nível do namespace e poderá ser usada em outros lugares (diferente de variáveis locais
que algumas linguagens possuem), mas não recomendamos isso - ao invés, você devereria
utilizar um bloco `let` para definir variáveis dentro de uma função.

[[function-section]]
=== Funções

==== O primeiro contato

É hora de fazer as coisas acontecerem. _Clojure_ possui o que conhecemos como
_first class functions_. Funções se comportam como qualquer outro tipo; você pode passá-las
como argumentos e retorná-las como valores, sempre respeitando o escopo léxico. _Clojure_
também possui algumas funcionalidades devido ao escopo dinâmica, mas vamos ver isso em
outra seção.

Se você quer saber mais sobre escopos, esse  link:https://pt.wikipedia.org/wiki/Escopo_(computa%C3%A7%C3%A3o))[Artigo da Wikipedia] é
bem completo e explica os diversos tipos de escopo.

Como _Clojure_ é um dialeto do Lisp, ela utiliza a notação prefixada para chamar funções:

[source, clojure]
----
(inc 1)
;; => 2
----

No exemplo acima, `inc` é uma função e é parte da _runtime_ do _Clojure_, e
`1` é o primeiro argumento para a função `inc`.

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

O símbolo de `+`  representa a função `add` (de adição). Ela permite múltiplos parâmetros,
enquanto em linguagens que seguem o estilo _ALGOL_, `+` é um operador e permite somente
dois parâmetros.

A notação prefixada possui algumas vantagens, que não são óbvias. _Clojure_
não faz distinção entre função e operador; tudo é uma função. A vantagem imediata é
que a notação prefixada permite um número arbitrário de argumentos por "operador".
Isso remove completamente o problema de precedência de operadores.

==== Definindo suas próprias funções

Você pode definir funções sem nome (anônimas) com a forma especial `fn`. Esse é um tipo
de definição de função; no exemplo seguinte, a função recebe dois argumentos e retorna
a média deles.

[source, clojure]
----
(fn [param1 param2]
  (/ (+ param1 param2) 2.0))
----

Você pode definir a função e chamá-la ao mesmo tempo (em uma única expressão):

[source, clojure]
----
((fn [x] (* x x)) 5)
;; => 25
----

Agora vamos criar algumas funções com nomes. Mas o que uma _função com nome_ significa?
Em _Clojure_ é bem simples, funções são _first-class_ e se comportam como qualquer outro valor.
Então, nomear uma função é feita simplesmente vinculando a função a um símbolo.

[source, clojure]
----
(def square (fn [x] (* x x)))

(square 12)
;; => 144
----

_Clojure_ também oferece uma macro `defn` que permite fazer a mesma coisa de uma
maneira mais idiomática:

[source, clojure]
----
(defn square
  "Return the square of a given number."
  [x]
  (* x x))
----

A string que vem entre o nome da função e o vetor de parâmetros é chamada de  _docstring_
(documentation string); existem programas que geram documentação a partir do código fonte
que utilizam essas _docstrings_.

==== Funções com múltiplas aridades (ou diferente números de argumentos)

_Clojure_ também vem com a habilidade de definir funções com um número arbitrário de argumentos.
(O termo _aridade_ signifca o número de argumentos que um função aceita.) A sintaxe é praticamente
idêntica a sintaxe de definição de uma função comum, com a pequana diferenção que ela contém mais
de um _body_(ou corpo de expressões).

Vejamos um exemplo, o qual vamos explicar melhor:

[source, clojure]
----
(defn myinc
  "Self defined version of parameterized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))
----

Essa linha: `([x] (myinc x 1))` diz que se a função for chamada somente com um argumento,
chame a função `myinc` com aquele argumento e o número `1`como segundo argumento. O outro
corpo de expressões `([x increment] (+ x increment))` dis que se houver dois
argumentos, retorna-se o resultado da adição deles.

Aqui estão mais alguns exemplos de como usar a função de múltipla aridade definida
anteriormente. Observe que se você chama uma função com o número errado de argumentos,
o compilador irá produzir uma mensagem de erro.

[source, clojure]
----
(myinc 1)
;; => 2

(myinc 1 3)
;; => 4

(myinc 1 3 3)
;; Compiler error
----

NOTE: Explicar o conceito de "aridade" está fora do escopo desse livro,
entretanto você pode ler mais sobre isso nesse link:https://pt.wikipedia.org/wiki/Aridade[ artigo da Wikipedia].

==== Funçòes de aridade variável

Outro jeito de aceitar múltiplo número de argumentos é definir uma função aridade variável.
Essas funções podem aceitar um número arbitrário de argumentos:
[source, clojure]
----
(defn my-variadic-set
  [& params]
  (set params))

(my-variadic-set 1 2 3 1)
;; => #{1 2 3}

(my-variadic-set 1 2)
;; => #{1 2}
----

A função acima aceita de 0 a quantos argumentos quisermos, podendo receber 1, 2, 3 ou até mais.
O jeito de definir uma função com aridade variável é utilizando o símbolo `&` como prefixo
no seu vetor de argumentos.

==== Sintaxe mais simmples para funções anônimas

_Clojure_ provê uma sintaxe mais compacta para definir funções anônimas usando a macro de leitura
`#()` (usualmente consistindo de somente uma linha). Macros de leitura são expressões
especiais que serão transformadas para algo compatível com a língua em tempo de compilação;
nesse caso, para uma expressão que usa a forma especial `fn`.

[source, clojure]
----
(def average #(/ (+ %1 %2) 2))

(average 3 4)
;; => 3.5
----

A definição precedente é uma jeito mais curto de escrever:

[source,clojure]
----
(def average-longer (fn [a b] (/ (+ a b) 2)))

(average-longer 7 8)
;; => 7.5
----
`%1`, `%2`... `%N` são marcadores simples da posição dos argumentos no vetor de argumentos
que são implicitamente declarados quando a macro de leitura vai interpretar e converter
essa forma em uma expressão `fn`.

Se a função aceitar somente um argumento, você pode omitir o número depois do `%`,
por exemplo, uma função eleva um número ao quadrado pode ser escrita tanto assim
`#(* %1 %1)` como assim `#(* % %)`.

Além disso, a sintaxe também suporta a forma de aridade variável com o símbolo `%&`:

[source, clojure]
----
(def my-variadic-set #(set %&))

(my-variadic-set 1 2 2)
;; => #{1 2}
----


=== Lógica de controle

_Clojure_ tem uma abordagem diferente a lógica de controle (if, else, for) do que outras linguagens
como JavaScript, C, etc.

==== Executando coisas diferentes com `if`

Vamos começar com o simples `if`. Em _Clojure_, o `if` é uma expressão e não uma
declaração, e ele recebe três parâmetros: o primeiro é a expressão de condição
(que define qual expressão vai ser executada), o segundo é a expresão que será executada
se a expressão de condição for evaluada para algo "verdadeiro", e a terceira expressão
vai ser executada caso contrário.

[source, clojure]
----
(defn discount
  "Você pode obter 5% de disconto se pedir 100 ou mais itens"
  [quantity]
  (if (>= quantity 100)
    0.05
    0))

(discount 30)
;; => 0

(discount 130)
;; => 0.05
----


O bloco de execução `do` pode ser usado para termos múltiplas expressoão em um `if`.
xref:block-section[`do` is explained in the next section].


==== Executando coisas diferentes com `cond`

Algumas vezes, a expressão `if` pode ser um pouco limitante porque ela não possui o
bloco "else if" para adicionarmos mais de uma condição. A macro `cond` resolve isso.

Com a expressão `cond`, podemos definir múltiplas expressões de condição:

[source, clojure]
----
(defn mypos?
  [x]
  (cond
    (> x 0) "positive"
    (< x 0) "negative"
    :else "zero"))

(mypos? 0)
;; => "zero"

(mypos? -2)
;; => "negative"

(mypos? 1)
;; => "positive"
----

Também, `cond` tem outra forma, chamada `condp`, que trabalha de forma muito similar com
que o `cond` trabalha, porém é um pouco mais simples quando a condição (também chamada de predicado0 é
a mesma para todas as condições:

[source, clojure]
----
(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----

A linha `condp = (keyword code)` significa que, em cada uma das linhas seguintes,
_Clojure_ vai aplicar a função `=` ao resultado de `(keyword code)` e o argumento
seguinte. Por exemplo para `:es`, será executado o seguinte: `(= :es (keyword code)`.

====  Case

O operador de controle `case` tem um uso similar ao exemplo do `condp`. A principal diferença
é que no `case` o predicado é sempre `=` e seus valores de controle (os `:es` e `:en` nos exemplos anteriores)
são evaluados em tempo de compilação. Isso resulta em algo mais performático que `cond` e `condp`, com a desvantagem
de os valores serem estáticos.

Aqui está o exemplo anterior, reescrito usando `case`:

[source, clojure]
----
(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "en" "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----


[[truthiness-section]]
=== O que é "Verdade" em _Clojure_?

Esse é um aspecto onde cada língua possui sua própria semântica. Maioria das línguas
consideram coleções vazias, o valor 0 e outras coisas como sendo "logicamente falso", isso é
levam para o `else` em um `if`. Em _Clojure_ diferente de outras línguas, somente duas coisas
são consideradas "logicamente falsas": `nil` e `false`. Todo o resto é tratado como
"logicamente  verdadeiro" (`true`).

Junto com a abilidade de implementar o protocolo "chamável" (_callable_, o `IFN` explicado com
mais detalhes mais tarde), estruturas de dados como sets podem ser usados como predicados, sem
a necessidade de adicionar funções:

[source, clojure]
----
(def valid? #{1 2 3})

(valid? 2)
;; => true

(valid? 4)
;; => nil

(filter valid? (range 1 10))
;; => (1 2 3)
----

Isso funciona porque um set retorna ou o valor do elemento se ele contiver esse elemento
ou `nil`:

[source, clojure]
----
(valid? 1)
;; => 1

(valid? 4)
;; => nil
----


=== Locals, Blocos, e Loops

==== Locals

_Clojure_ não possui o conceito de variáveis como linguagens similares ao `ALGOL` possuem,
mas ele possui o conceito de locals. Locals, como sempre, são imutáveis, e se você tentar
mudá-los, o compilador vai lançar uma exceção.

Locals são definidos usando a expressão `let`. Essa expressão começa com um vetor de vínculos
e por um número arbitrário de expressões (que chamámos de let-body ou corpo do `let`). O vetor de vínculos
deve contar um número arbitrário de pares, onde o primeiro item do par é normalmente um símbolo e
o segundo item, o valor daquele símbolo, que será usado no corpo do `let`.

[source, clojure]
----
(let [x (inc 1)
      y (+ x 1)]
  (println "Uma simples mensagem do corpo do  let")
  (* x y))
;; Uma simples mensagem do corpo do let
;; => 6
----

No exemplo precedente, o símbolo `x` está vinculado ao valor `(inc 1)`, que é evaluado
como `2`, e o símbolo `y` está vinculado a soma de `x` e `1`, que passa a ser 3. Dado esses
vínculos, as expressões `(println "Uma simples mensagem do corpo do  let")` e `(* x y)` são
evaluadas.

==== Blocos

Blocos de expressões que devem estar juntas, são criados usando a expressão  `do` em _Clojure_
e normalmente são usado para "efeitos" (side effects), como imprimir algo no console ou
logar algo.

Um side effect é alguma coisa que não precisa necessariamente retornar um valor.

A expressão `do` aceita como argumento um número arbitrário de outras expressões, mas retorna
somente o valor da última expressão:

[source, clojure]
----
(do
  (println "hello world")
  (println "hola mundo")
  (* 3 5) ;; this value will not be returned; it is thrown away
  (+ 1 2))

;; hello world
;; hola mundo
;; => 3
----

O corpo de uma expressão `let`, explicado anteriormente, é muito parecido com a expressão `do`
no sentido que aceita múltiplas expressões. Na verade, o bloco `let` possui um bloco `do` implícito. 

==== Loops

A abordagem funcional de _Clojure_ significa que ela não possui o tradicional loop
`for` de outras línguas como _C_. Os loops em _Clojure_ funcionam através de recursão.
Recursão algumas vezes precisa de um esforço adicional de como modelar um problema
um pouco diferente de como se faz em linguagens imperativas.

Muitas dos usos comuns para qual `for` é utilizado em outras línguas são obtidos com funções
de `high-order` - isso é, funções que aceitam outras funções como parâmetros.

===== Looping com loop/recur

Vamos dar uma olhada em como expressar loops usando recursão com as formas
`loop` e  `recur`. `loop` define uma lista de vínculos (observe a simetria com `let`)
e `recur` retorna a execução de volta para o loop com novos valores para esses vínculos.

Vamos ver um exemplo:

[source, clojure]
----
(loop [x 0]
  (println "Looping com " x)
  (if (= x 2)
    (println "Terminei o loop!")
    (recur (inc x))))
;; Looping com 0
;; Looping com 1
;; Looping com 2
;; Terminei o loop!
;; => nil
----

No código acima, nos vinculamos o nome `x` ao valor `0` e executamos o corpo do loop.
Como a condição não é verdadeira na primeira vez, ela é roda novamente com o `recur`,
com o novo vínculo de `x` sendo `1`, resultado do `(inc x)`. Fazemos isso mais uma vez
até que a condição é satisfeita, e não ocorram outras chamadas do `recur` e saímos do loop.

Observe que não estamos restritos a usar o `recur` somente dentro do `loop`. Podemos
usá-lo também na execução do corpo de uma função recursiva:

[source, clojure]
----
(defn recursive-function
  [x]
  (println "Looping com" x)
  (if (= x 2)
    (println "Done looping!")
    (recur (inc x))))

(recursive-function 0)
;; Looping com 0
;; Looping com 1
;; Looping com 2
;; Terminei o loop!
;; => nil
----


===== Substituindo loops por funções de _high-order_

Em linguagens de programação imperativas, é comum o uso de `for` loops para iterar
dados e transformá-los, usualmente com algum dos objetivos abaixo:

- Transformar cada valor na coleção retornando uma nova coleção
- Filtrar alguns elementos na coleção baseado em algum critério
- Converter uma coleção em um valor onde cada iteração depende do resultado da iteração
anterior
- Rodar algum tipo de rotina para cada valor na coleção

As ações acimas são expressas em funções de _high-oder_ e em construções sintáticas do _Clojure_,
vamos ver um exemplo para as três primeiras.

Para transformar cada valor em uma coleção, nos usamos a função `map`, que
recebe uma função e uma sequência e aplica essa função em cada elemento:

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)
----

O primeiro argumento do `map` pode ser qualquer função que receba *um argumento*
e retorne um valor. Por exemplo, se você tiver uma aplicação gráfica e quiser
desenhar o gráfico da equação  `y&#160;=&#160;3x&#160;+&#160;5` para algum conjunto
de valores de `x`,  você poderia obter os valores de `y` assim:

[source, clojure]
----
(defn y-value [x] (+ (* 3 x) 5))

(map y-value [1 2 3 4 5])
;; => (8 11 14 17 20)
----

Se a função de mapeamento é pequena, você pode usar uma função anônima, seja com a forma
normal ou com a sintaxe `#()`:

[source, clojure]
----
(map (fn [x] (+ (* 3 x) 5)) [1 2 3 4 5])
;; => (8 11 14 17 20)

(map #(+ (* 3 %) 5) [1 2 3 4 5])
;; => (8 11 14 17 20)
----

Para filtrar valores em uma coleção, nos usamos a função `filter`, que recebe um
predicado e uma sequência e retorna uma nova sequência somente com os elementos
que retornaram algum valor "logicamente true" para o predicado fornecido:

[source, clojure]
----
(filter odd? [1 2 3 4])
;; => (1 3)
----

Novamente, você pode usar qualquer função que retorne `true` ou `false` como o primeiro
argumento do `filter`. Aqui está um exemplo que mantém somente as palavras com menos
de 5 letras. (A função `count` retorna o comprimento da coleção passada como argumento -
uma string é uma coleção de caracteres.)

[source, clojure]
----
(filter (fn [word] (< (count word) 5)) ["ant" "baboon" "crab" "duck" "echidna" "fox"])
;; => ("ant" "crab" "duck" "fox")
----

Convertendo uma coleção para um único valor, acumulando o resultado intermediário a
cada passo da iteraçào pode ser obtido usando a função `reduce`, que recebe uma função
para acumular os valores, um valor inicial opcional e uma coleção:

[source, clojure]
----
(reduce + 0 [1 2 3 4])
;; => 10

(reduce + [1 2 3 4])
;; => 10

----

Uma outra vez, podemos usar nossa própria função como argumento do `reduce`, mas ela
deve receber *dois* argumentos. O primeiro é o resultado intermediário e o segundo
é o item da coleção sendo processado. A função retorna o valore que se torna o novo
resultado intermediário para ser usado junto com o próximo item na lista. Por exemplo,
aqui está o que você obtém a soma dos quadrados de um conjunto de números.

[source, clojure]
----
(defn sum-squares
  [accumulator item]
  (+ accumulator (* item item)))

(reduce sum-squares 0 [3 4 5])
;; => 50
----

Agora com uma função anônima:

[source, clojure]
----
(reduce (fn [acc item] (+ acc (* item item))) 0 [3 4 5])
;; => 50
----

Aqui um `reduce` que encontra o total de número de caracteres de um conjunto de palavras:

[source, clojure]
----
(reduce (fn [acc word] (+ acc (count word))) 0 ["ant" "bee" "crab" "duck"])
;; => 14
----

Aque não usamos a sintaxe `#()`, porque apesar de reduzirmos o tamanho do código, ficaria
menos legível.

Lembre-se de escolher o valor inicial do seu acumulador com atenção. Se você quiser
usar o `reduce` para encontrar a multiplicação de uma série de números, você teria
que começar com 1 ao invés de 0, se não, estaríamos multiplicando os números por zero!

[source, clojure]
----
;; valor inicial errado
(reduce * 0 [3 4 5])
;; => 0

;; valor inicial correto
(reduce * 1 [3 4 5])
;; => 60
----


===== `sequências for`

Em _Clojure_, o `for` não é usado para iteração, mas para gerar uma sequência, uma
operação também conhecida como "sequence comprehension". Em esta seção, você vai aprender
como ela funciona e como usá-la para construir sequências declarativas.

`for` recebe um vetor de vínculos e uma expressão e gera uma sequência com o resultado
de evaluar cada expressão. Vamos ver um exemplo:

[source, clojure]
----
(for [x [1 2 3]]
  [x (* x x)])
;; => ([1 1] [2 4] [3 9])
----

Nesse exemplo, `x` seria vinculado a cada item do vetor `[1 2 3]` por vez,
e retornaria uma nova sequência onde cada item é um vetor de dois itens com o item
original e o quadrado dele.

`for` suporta vários vínculos, o que vai fazer a coleção ser iterada em uma maneira
aninhada, muito parecido quando colocamos `for` dentro de `for` em uma linguagem imperativa.
O vínculo mais interno itera "mais rápido".

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]]
  [x y])

;; => ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])
----

Podemos também colocar depois dos vínculos, três modificadores: `:let` para
criar vínculos locais, `:while` para parar a geração da sequência, e `:when`para
filtrar valores.

Aqui está um exemplo de vínculos locais utilizando o modificador `:let`, note
que os vínculos definitos estarão disponíveis na expressão:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; => (5 6 6 7 7 8)
----

Podemos utilizar o modificador `:while` para expressar a condição que uma vez que deixar
de ser verdade, vamos parar a geraçào da sequência. Aqui está um exemplo:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])

;; => ([1 4] [2 4] [3 4])
----

Para fitrar os valores gerados, podemos usar o modificador `:when` como no exemplo
a seguir:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])

;; => ([1 5] [2 4])
----

Podemos combinar os modificados acima para expressar geração de sequências mais complexas
ou expressar a intenção do nosso `for` loop de maneira mais clara:

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])

;; => ([1 5] [2 4])
----

Quando listamos os usos mais comuns do `for` loop em linguagens imperativas,
nós mencionamos que algumas vezes queremos rodar alguma rotina pra
cada valor na sequência, sem nos importarmos com o resultado. Normalmente,
fazemos isso para realizar algum efeito (_side-effect_) com os valores da sequência.


_Clojure_ provê o construtor `doseq`, que é análogo ao `for`, mas executa a expressão,
descarta o resultado, e retorna `nil`. Como o `for`, ele aceita os mesmos modificadores
`:let`, `:when` e `:while`.

[source, clojure]
----
(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))

;; 1 + 4 = 5
;; 1 + 5 = 6
;; 2 + 4 = 6
;; 2 + 5 = 7
;; 3 + 4 = 7
;; 3 + 5 = 8
;; => nil
----

Se você quer simplesmente iterar e aplicar alguma rotina com efeito (_side-effect_) como
`println` para cada item na coleção, você usar a função especializada `run!` que internamente
usa uma "redução" mais rápida.

[source, clojure]
----
(run! println [1 2 3])
;; 1
;; 2
;; 3
;; => nil
----

Essa função explicitamente retorna `nil`.


=== Tipos de coleções

==== Imutáveis e persistentes

Como mencionamos antes, as coleções no _Clojure_ são persistentes e imutáveis, mas
nós não explicamos o que isso significa.

Uma estrutura de dado imutável, como o nome sugere, são estrutura de dados que não
podem ser mudadas. Alterações in-loco não são permitidas em estruturas imutáveis.

Vamos ilustrar isso com um exemplo: adicionando valores a um vetor usando `conj`(conjoin).

[source, clojure]
----
(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))

;; xs: [1 2 3]
;; ys: [1 2 3 4]
;; => nil
----

Como você pode ver, nós derivamos uma versão do vetor `xs` ao adicionar um elmento
a ele, e obtemos um novo vetor `ys` com esse elemento adicionado. Entretanto,
o vetor `xs` se mantém inalterado, porque ele é imutável.

Uma estrutura persistente é uma estrutura de dados que retorna uma nova versão
dela mesmo enquanto a transforma, deixando o original não modificado. _Clojure_
faz isso ser eficiente em termos de memória e tempo usando uma técnica de implementação
chamada _structural sharing_ (compartilhamento de estrutura), onde a maioria dos dados
são compartilhados entre as duas versões e não duplicada e as transformações
copiam o mínimo possível de dados.

Se você quer saber mais como esse compartilhamento funciona, continue lendo. Se não
está interessado em saber mais dos detalhes, sinta-se livre para pular para xref:the-sequence-abstraction[próxima seção].

Para ilustrar melhor esse _structural sharing_ nas estruturas do _Clojure_, vamos
comparar se algumas partes da velha e nova versão da estrutura de dados são
na verdade o mesmo objeto usando a função `identical?`. Nós vamos usar uma lista
para isso:

[source, clojure]
----
(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))

;; xs: (1 2 3)
;; ys: (0 1 2 3)
;; (rest ys): (1 2 3)
;; => true
----

Como você pode ver no exemplo, nós usamos `cons` (construct0 para prefixar um valor
a lista `xs` e obtemos uma nova lista `ys` com o elemento adicionado. O resto de `ys`
obtidos usando a função `rest`, é o mesmo objeto em memória que a lista `xs`, e então
`xs` e `ys` compartilham a mesma estrutura.


[[the-sequence-abstraction]]
==== A Abstração de Sequências

Uma das abstrações centrais do _Clojure_ é a _sequence_ que pode ser pensando como
uma lista e pode ser derivada de qualquer tipo de coleção. É uma coleção persistente
e imutável como todos os tipos de coleção, e muitas funções centrais do _Clojure_
retornam sequências.

Os tipos que podem ser usados para gerar uma sequência são chamados de  "seqables";
nos podemos chamar `seq` com eles como argumento e obter uma sequência de volta.
Sequências suportam duas operações básicas: `first` e `rest`. Ambas chamam `seq`
no argumento fornecidos a eles:

[source, clojure]
----
(first [1 2 3])
;; => 1

(rest [1 2 3])
;; => (2 3)
----

Chamando `seq` em um _seqable_, podemos obter resultados diferentes se o _seqable_ está
vazio ou não. Ele irá retornar `nil` quando a coleção está vazia ou se não, uma sequence:

[source, clojure]
----
(seq [])
;; => nil

(seq [1 2 3])
;; => (1 2 3)
----

`next` é similar a operação `rest`, exceto que ela retorna `nil` quando chamada
com uma sequência com um ou zero elementos. note que, quando chamamos `rest` com
uma sequência vazia, ela retornará um valor "logicamente true"(`()`), enquanto `next`
irá retornar um valor "logicalmente false" (`nil`).
(xref:truthiness-section[revise a seção sobre "O que é verdade em Clojure" caso tenha alguma dúvida sobre isso]).

[source, clojure]
----
(rest [])
;; => ()

(next [])
;; => nil

(rest [1 2 3])
;; => (2 3)

(next [1 2 3])
;; => (2 3)
----


===== nil-punning

Como `seq` retorna `nil` quando a coleção está valia, e `nil` é considerado um valor
"logicalmente false", você pode checar se uma coleção está vazia usando a função `seq`.
O termo técnico para isso é nil-punning.

[source, clojure]
----
(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))

(print-coll [1 2 3])
;; Vi 1
;; Vi 2
;; Vi 3
;; => nil

(print-coll #{1 2 3})
;; Vi 1
;; Vi 3
;; Vi 2
;; => nil
----

Apesar de `nil` não ser  nem um _seqable_ nem uma sequência, ele é suportado por todas
as funções que vimos até agora:

[source, clojure]
----
(seq nil)
;; => nil

(first nil)
;; => nil

(rest nil)
;; => ()
----


===== Funções que trabalham com sequências

As funções centrais do _Clojure_ para transformar coleções criam sequências a partir
dos seus argumentos e são implementadas em termos das operações genéricas que aprendemos
na seção precedente. Isso faz com que elas sejam super genéricas porque podemos usar
em qualquer tipo de dado que seja um _seqable_. vamos ver como `map` funciona nos diversos
tipos de coleções:

[source, clojure]
----
(map inc [1 2 3])
;; => (2 3 4)

(map inc #{1 2 3})
;; => (2 4 3)

(map count {:a 41 :b 40})
;; => (2 2)

(map inc '(1 2 3))
;; => (2 3 4)
----

NOTE: Quando usamos `map` em uma coleção do tipo map, sua função de mapeamento irá receber como
argumento um vetor com dois items, contendo chave e valor contidos no mapa.
O exemplo abaixo usa xref:destructuring-section[destructuring] para acessar a chave e o valor de maneira mais simples.

[source,clojure]
----
(map (fn [[key value]] (* value value))
     {:ten 10 :seven 7 :four 4})
;; => (100 49 16)
----

Obviamente a mesma operação pode ser feita de forma mais idiomática obtendo somente uma
_seq_ dos valores do mapa:

[source,clojure]
----
(map (fn [value] (* value value))
     (vals {:ten 10 :seven 7 :four 4}))
;; => (100 49 16)
----

Como você pode notar, funções que operam em sequências são seguras para serem
usadas com coleções vazias ou até mesmo `nil` já que elas não precisam fazer nada
a não ser retornar um sequência vazia quando encontram tais valores.

[source, clojure]
----
(map inc [])
;; => ()

(map inc #{})
;; => ()

(map inc nil)
;; => ()
----

Nós já vimos alguns exemplos com as funções como `map`, `filter`, e `reduce`, mas
_Clojure_ fornece uma variedade de funções genéricas que operam em sequências no
seu _core namespace_. Note qua muitas das operações que aprendemos até agora
funcionam com _seqables_ e são extensíveis a tipos definidos pelo usuário.

Podemos verificar se um valor é uma coleção através da função predicado
`coll?`:

[source, clojure]
----
(coll? nil)
;; => false

(coll? [1 2 3])
;; => true

(coll? {:language "ClojureScript" :file-extension "cljs"})
;; => true

(coll? "ClojureScript")
;; => false
----

Existem funções predicados similares para checarem se um valor é uma sequência (`seq?`) ou
um _seqable_ (`seqable?`):

[source, clojure]
----
(seq? nil)
;; => false
(seqable? nil)
;; => false

(seq? [])
;; => false
(seqable? [])
;; => true

(seq? #{1 2 3})
;; => false
(seqable? #{1 2 3})
;; => true

(seq? "ClojureScript")
;; => false
(seqable? "ClojureScript")
;; => false

(seq? '(1 2 3))
;; => true
(seqable? '(1 2 3))
;; => true
----

Para coleções que podem ser contadas em tempo constante, podemos utilizar a
função `count`. Essa operação inclusive funciona com strings, apesar de elas não serem
uma coleção, sequência, ou seqable.

[source, clojure]
----
(count nil)
;; => 0

(count [1 2 3])
;; => 3

(count {:language "ClojureScript" :file-extension "cljs"})
;; => 2

(count "ClojureScript")
;; => 13
----

Nós também podemos obterm uma variante vazia de uma certa coleção através da
função `empty`:

[source, clojure]
----
(empty nil)
;; => nil

(empty [1 2 3])
;; => []

(empty #{1 2 3})
;; => #{}
----

A função predicado `empty?` retorna `true` se uma certa coleção está vazia:

[source, clojure]
----
(empty? nil)
;; => true

(empty? [])
;; => true

(empty? #{1 2 3})
;; => false
----

A função `conj`(conjoin) adiciona um elemento a um coleção e pode adicionar ela
em diferentes "lugares" dependendo do tipo da coleção. O elemento é adicionado
onde é mais performático, mas note que nem toda coleção possui uma ordem definida.

Podemos passar muitos elementos quanto quisermos para `conj`; vamos ver alguns exemplos:

[source, clojure]
----
(conj nil 42)
;; => (42)

(conj [1 2] 3)
;; => [1 2 3]

(conj [1 2] 3 4 5)
;; => [1 2 3 4 5]

(conj '(1 2) 0)
;; => (0 1 2)

(conj #{1 2 3} 4)
;; => #{1 3 2 4}

(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; => {:language "ClojureScript", :file-extension "cljs"}
----


===== Laziness/Preguiça

Maioria das funções que retornam sequência no _Clojure_ retornam uma sequência "preguiçosa"
ao invés de calcular todos os elementos da nova sequênica. Sequências _Lazy_ geram seu
conteúdo a medida que são solicitadas a fazê-lo, normalmente quando estamos iterando sob
elas. Laziness/Preguiça garante que não estamos fazendo mais trabalho do que precisamos e nos dá
a possibilidade de tratar sequências potencialmente infinitas como sequências comuns.

Considere a função `rage`, que gera uma sequência de inteiros:

[source, clojure]
----
(range 5)
;; => (0 1 2 3 4)
(range 1 10)
;; => (1 2 3 4 5 6 7 8 9)
(range 10 100 15)
;; (10 25 40 55 70 85)
----

Se você dizer apenas `(range)`, você irá obter uma sequência de todos os inteiros.
Não tente isso dentro de uma REPL, pois ela tentará evaluar a expressão e todos os
elementos da sequência.


Aqui está um exemplo controlado. Supondo que você esteja escrevendo um programa
gráfico e queira desenhar o gráfico da equação _y_= 2 _x_ ^2^ + 5, e queira somente
aqueles valores de `x` para quais `y` é menor que 100. Você pode geral todos os números
entre 0 e 100, que certamente serão suficientes, e então usar `take-while` com a condição `y <= 100`:
[source,clojure]
----
(take-while (fn [x] (< (+ (* 2 x x) 5) 100))
            (range 0 100))
;; => (0 1 2 3 4 5 6)
----

==== Entendendo Coleções a fundo

Agora que conhecemos a abstração de serquências de Clojure e algum das funções
para manipulá-las, é hora de conhecermos alguns tipos de coleções concretas
e as operações que elas suportam.

===== Listas

Em _Clojure_, listas são uma estrutura de dados usada principalmente par agrupar
símbolos juntos para criar programas. Diferente de outras Lisps, muitas construções
sintáticas do _Clojure_ usam estruturas sintáticas diferentes da lista (como vetores e mapas).
Isso torna o código menos uniforme, porém aumenta a facilidade de leitura.

Você pode pensar nas listas do _Clojure_ como listas ligadas (mas não duplamente), onde
cada nó contém um valor e um ponteiro para o resto da lista. Isso faz com que seja
natural (e rápido) adicionar items ao começo da lista, já que adicionar ao fim iria
criar a necessidade de percorrer toda a lista. Essa adição é feita utilizando
a função `cons`.

[source, clojure]
----
(cons 0 (cons 1 (cons 2 ())))
;; => (0 1 2)
----

Nós usamos a sintaxe literal `()` para representar uma lista vazia. Já que ela não
contém nenhum símbolo, não é tratada como uma chamada de função. porém, quando usando
a sintaxe literal de listas que contenham elementos, precisamos prefixá-la com aspa
`'` para previnir que _Clojure_ evalue ela como uma chamada de função:

[source, clojure]
----
(cons 0 '(1 2))
;; => (0 1 2)
----

Como adicionar ao começo (ou cabeça, ou head) leva tempo constante para ser
feito, a função `conj` operando em listas adiciona items ao começo.

[source, clojure]
----
(conj '(1 2) 0)
;; => (0 1 2)
----

Listas e outras estruturas de dados do _Clojure_ podem ser usadas como pilhas
usando as funções `peek`, `pop` e `conj`. Note que o topo da pilha será o lugar
onde `conj` vai adicionar elementos, fazendo `conj` equivalente a função `push`
de uma pilha. No caso de listas, `conj` adiciona elementos no começo da lista,
e `peek` retorna o primeiro elemento da lista, e `pop` retorna a lista com todos
os elementos exceto o primeiro.

Note que as duas operações que retornam a pilha (`conj` e `pop`) não mudam o tipo da
coleção usada pela pilha.

[source, clojure]
----
(def list-stack '(0 1 2))

(peek list-stack)
;; => 0

(pop list-stack)
;; => (1 2)

(type (pop list-stack))
;; => cljs.core/List

(conj list-stack -1)
;; => (-1 0 1 2)

(type (conj list-stack -1))
;; => cljs.core/List
----

Uma coisa que listas não particularmente goas é acesso arbitrário de elementos através
de um index. Como elas são armazenadas como listas ligadas em memória, para acesso arbitrário
a um certo index, é necessário percorrer a lista em ordem para obter o elemento desejado, ou
lançar uma exceção de index não presente na lista, caso o index maior que a quantidade
de elementos na lista. Outras coleções que não possuem index também sofrem
dessa limitação como _lazy sequences_ .

===== Vetores

Vetores são uma das estruturas de dados mais comum em _Clojure_. Elas são usadas como
estrutura sintática em vários lugares em que Lisps mais tradicionais utilizam lista, como
por exemplo em declaração de argumentos de funções e em blocos de vínculos `let`.

Vetores em _Clojure_ são delimitados por cochetes `[]` como sintaxe literal. Eles
também podem ser criados com a função `vector` ou a partir de outra coleção
utilizando a função `vec`:

[source,clojure]
----
(vector? [0 1 2])
;; => true

(vector 0 1 2)
;; => [0 1 2]

(vec '(0 1 2))
;; => [0 1 2]
----

Vetores são, como listas, coleções ordenadas de valores heterogêneos. Diferente de listas,
vetores crescem naturalmente a partir do fim deles (ou cauda), então a função `conj`
adiciona itens ao final do vetor. Adições ao fim do vetor são feitas em tempo constante:

[source,clojure]
----
(conj [0 1] 2)
;; => [0 1 2]
----

Outra coisa que diferencia listas de vetores é que vetores são coleções indexadas
e suportam acesso eficiente a items através de índices e atualizações nào destrutivas.
Nós usamos a função `nth` para obter valores de um certo index:

[source, clojure]
----
(nth [0 1 2] 0)
;; => 0

(nth [0 1 2] 2)
;; => 2

----

Como vetores associam chaves sequênciais númericas (indexes) aos valroes, podemos
tratar eles como uma estrutura associativa. _Clojure_ provê a função `assoc`
que dado uma estrutura de dados associativa, um conjunto de pares de chave e valores
retorna uma nova estrutura de dados com as chaves fornecidas modificadas. O index
começa em 0 referindo-se ao primeiro elemento do vetor. 

[source, clojure]
----
(assoc ["cero" "uno" "two"] 2 "dos")
;; => ["cero" "uno" "dos"]
----

Note que podemos somente associar uma chave que já está no vetor ou é a última
posição do vetor (fazendo ele crescer):

[source, clojure]
----
(assoc ["cero" "uno" "dos"] 3 "tres")
;; => ["cero" "uno" "dos" "tres"]

(assoc ["cero" "uno" "dos"] 4 "cuatro")
;; Error: Index 4 out of bounds [0,3]
----

Algo supreendente é que estruturas de dados associativas podem ser usadas
como funções. Elas sào funções das suas chaves para os valores associado a elas.
No caso dos vetores, se uma certa chave não está presente uma exceção é
lançada:

[source, clojure]
----
(["cero" "uno" "dos"] 0)
;; => "cero"

(["cero" "uno" "dos"] 2)
;; => "dos"

(["cero" "uno" "dos"] 3)
;; Error: Not item 3 in vector of length 3
----

Como listas, vetores podem também ser usadas como pilhas com as funções `peek`, `pop`
e `conj`. É importante notar que vetores crescem na direção contrária das listas:

[source, clojure]
----
(def vector-stack [0 1 2])

(peek vector-stack)
;; => 2

(pop vector-stack)
;; => [0 1]

(type (pop vector-stack))
;; => cljs.core/PersistentVector

(conj vector-stack 3)
;; => [0 1 2 3]

(type (conj vector-stack 3))
;; => cljs.core/PersistentVector
----

As funções `map` e `filter` são operações que retornam uma _lazy sequence_, mas é comum
precisarmos de sequências onde todos os valores já foram computados. Por isso,
existem as funções `mapv` e `filterv` que funcionam igual `map` e `filter` porém
retornam vetores. Elas tem a vantagem de serem mais rápidas do que construir um vetor
a partir de uma _lazy sequence_ e fazendo a intenção do código mais explícita:

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)

(type (map inc [0 1 2]))
;; => cljs.core/LazySeq

(mapv inc [0 1 2])
;; => [1 2 3]

(type (mapv inc [0 1 2]))
;; => cljs.core/PersistentVector
----

===== Mapas

Mapas são onipresente em _Clojure_. Como vetores, eles também são usados
como parte da sintaxe da linguagem, principalmente para adição de xref:metadata-section[metadadaos]
a uma var. Qualquer estrutura de dados em _Clojure_ pode ser usada como
uma chave em um mapa, apesar de ser comum usarmos _keywords_ pois elas
também podem ser chamadas como funções.

Mapas em _Clojure_ são escritos literalmente como pares chave-valor envoltos
por chaves `{}`. Alternativamente, eles também pode ser criados usando a
função `hash-map`:

[source,clojure]
----
(map? {:name "Cirilla"})
;; => true

(hash-map :name "Cirilla")
;; => {:name "Cirilla"}

(hash-map :name "Cirilla" :surname "Fiona")
;; => {:name "Cirilla" :surname "Fiona"}
----

Como mapas não possuem uma ordem específica, a função `conj` apenas adiciona um
ou mais pares de chave-valor ao mapa. `conj` para mapas espera um ou mais sequência
de pares chave-valor como seus últimos argumentos:

[source,clojure]
----
(def ciri {:name "Cirilla"})

(conj ciri [:surname "Fiona"])
;; => {:name "Cirilla", :surname "Fiona"}

(conj ciri [:surname "Fiona"] [:occupation "Wizard"])
;; => {:name "Cirilla", :surname "Fiona", :occupation "Wizard"}
----

No exemplo anterior, por causalidade, a ordem foi preservada, mas para muitas chaves,
você verá que a ordem não é preservada.

Mapas associam chaves a valores e são portanto uma estrutura de dados associativa.
Eles suportam a adição de novas associaçòes usando a função `assoc` e, diferente de vetores,
a remoção usando `dissoc`. `assoc` também pode atualizar valores de uma chave existente.
Vamos ver como essas funções funcionam:

[source,clojure]
----
(assoc {:name "Cirilla"} :surname "Fiona")
;; => {:name "Cirilla", :surname "Fiona"}
(assoc {:name "Cirilla"} :name "Alfonso")
;; => {:name "Alfonso"}
(dissoc {:name "Cirilla"} :name)
;; => {}
----

Mapas também são funções das suas chaves, retornando os valores relacionados com
a chave passada como argumentol. Diferente de vetores, eles retornam `nil` caso a
chave não esteja presente no mapa:

[source,clojure]
----
({:name "Cirilla"} :name)
;; => "Cirilla"

({:name "Cirilla"} :surname)
;; => nil
----

_Clojure_ também fornece hash maps ordenados que se comportam como sua versão não ordenada
mas preservam a ordem quando iteramos sob seus elementos. Podemos criar um mapa ordenado
com um ordenamento padrão usando a função `sorted-map`:

[source,clojure]
----
(def sm (sorted-map :c 2 :b 1 :a 0))
;; => {:a 0, :b 1, :c 2}

(keys sm)
;; => (:a :b :c)
----

Se precisarmos de um ordenamento diferente, podemos prover uma função comparadora
a função `sorted-map-by`, vamos ver um exemplo em que invertemos a ordem retornada
pela função `compare`. Uma função comparadora recebe dois items para comparar
e retorna -1 (se o primeiro item é menor que o segundo), 0 (se eles são iguais) e
1 (se o primeiro item é maior que o segundo).

[source,clojure]
----
(defn reverse-compare [a b] (compare b a))

(def sm (sorted-map-by reverse-compare :a 0 :b 1 :c 2))
;; => {:c 2, :b 1, :a 0}

(keys sm)
;; => (:c :b :a)
----


===== Conjuntos (ou Sets)

Sets em _Clojure_ também possuem uma sintaxe literal que é `#{}` e também podem
ser criados utilizando a função `set`. Eles são coleções não ordenadas de valores sem
duplicações.

[source,clojure]
----
(set? #{\a \e \i \o \u})
;; => true

(set [1 1 2 3])
;; => #{1 2 3}
----

A sintaxe literal não permite duplicações. Se você escrever um set literal com duplicações
um erro será lançado:

[source,clojure]
----
#{1 1 2 3}
;; clojure.lang.ExceptionInfo: Duplicate key: 1
----
Existem várias operações que podem ser realizadas com sets, porem elas estão
localizadas no _namespace_ `clojure.set` e portanto precisam ser importadas. Você vai
aprender xref:namespace-section[os detalhes sobre namespaces] mais tarde, por hora, você só
precisa saber que estamos carregando um _namespace_ chamado `clojure.set` e vinculá-lo
ao símbolo `s`:

[source,clojure]
----
(require '[clojure.set :as s])

(def danish-vowels #{\a \e \i \o \u \æ \ø \å})
;; => #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(def spanish-vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(s/difference danish-vowels spanish-vowels)
;; => #{"å" "æ" "ø"}

(s/union danish-vowels spanish-vowels)
;; => #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(s/intersection danish-vowels spanish-vowels)
;; => #{"a" "e" "i" "o" "u"}
----

Uma propriedade interessante dos sets é que eles podem ser aninhados. Linguagens
que possuem sets mutáveis podem acabar contendo valores duplicados, mas isso não
pode acontecer no _Clojure_. Todas as estruturas de dado do _Clojure_ podém ser aninhadas
de forma arbitrária devido a imutabilidade.

Sets também suportam a operação genérica `conj` como todas as outras coleções suportam.

[source,clojure]
----
(def spanish-vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(def danish-vowels (conj spanish-vowels \æ \ø \å))
;; => #{"a" "e" "i" "o" "u" "æ" "ø" "å"}

(conj #{1 2 3} 1)
;; => #{1 3 2}
----

Sets funcionam como uma estrutura associativa que associam os valores que ele contém a eles
mesmos. E como qualquer valore exceto `nil` e `false` são "logicamente verdade" em
_Clojure_, podemos usar os sets como funções predicados:

[source,clojure]
----
(def vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(get vowels \b)
;; => nil

(contains? vowels \b)
;; => false

(vowels \a)
;; => "a"

(vowels \z)
;; => nil

(filter vowels "Hound dog")
;; => ("o" "u" "o")
----
Sets também possuem uma variante ordenada como mapas que é criada
utilizando as funções `sorted-set` e `sorted-set-by` que são análogas as funções
`sorted-map` e `sorted-map-by`.

[source,clojure]
----
(def unordered-set #{[0] [1] [2]})
;; => #{[0] [2] [1]}

(seq unordered-set)
;; => ([0] [2] [1])

(def ordered-set (sorted-set [0] [1] [2]))
;; =># {[0] [1] [2]}

(seq ordered-set)
;; => ([0] [1] [2])
----



===== Filas

_Clojure_ também provê uma fila persistente e imutável. Filas não são usadas tanto
quanto outros tipos de coleções. Elas podem ser criadas utilizando a sintaxe literal
`#queue []`, mas não existe uma função para criá-las.
ClojureScript also provides a persistent and immutable queue. Queues are not used as
pervasively as other collection types.  They can be created by simply getting the empty
queue: `(clojure.lang.PersistentQueue/EMPTY)`. Porém não existe nenhuma função
construtora para criá-las.

[source,clojure]
----
(def pq (conj (clojure.lang.PersistentQueue/EMPTY) 1 2 3))
;; => #object[clojure.lang.PersistentQueue 0x28cb9120 "clojure.lang.PersistentQueue@7861"]
----

Usar `conj` para adiconar valores a files, os adiciona ao fim dela:

[source,clojure]
----
(def pq (conj (clojure.lang.PersistentQueue/EMPTY) 1 2 3))
;; => #object[clojure.lang.PersistentQueue 0x28cb9120 "clojure.lang.PersistentQueue@7861"]

(last (conj pq 4 5))
;; => 5
----

Infelizmente, as filas não são impressas de forma muito legível na Repl.
É importante lembrar que as operações que usamos para pilha funcionam de maneira
diferente para filas. `pop` retira valores do começo da fila, e `conj` coloca valores
no fim da fila.

[source,clojure]
----
(def pq (conj (clojure.lang.PersistentQueue/EMPTY) 1 2 3))
;; => #object[clojure.lang.PersistentQueue 0x28cb9120 "clojure.lang.PersistentQueue@7861"]

(peek pq)
;; => 1

(println (mapv identity (pop pq)))
;; => [2 3]

(println (mapv identity (conj pq 4)))
;; => [1 2 3 4]
----

Filas não são usadas com muita frequência como lista ou vetores, mas é bom saber
que elas estão disponíveis em _Clojure_, e podem eventualmente serem úteis.


[[destructuring-section]]
=== Destructuring

Destructuring, as its name suggests, is a way of taking apart structured data such
as collections and focusing on individual parts of them. ClojureScript offers a
concise syntax for destructuring both indexed sequences and associative data
structures that can be used any place where bindings are declared.

Let's see an example of what destructuring is useful for that will help us
understand the previous statements better. Imagine that you have a sequence but are
only interested in the first and third item. You could get a reference to them
easily with the `nth` function:

[source, clojure]
----
(let [v [0 1 2]
      fst (nth v 0)
      thrd (nth v 2)]
  [thrd fst])
;; => [2 0]
----

However, the previous code is overly verbose. Destructuring lets us extract values
of indexed sequences more succintly using a vector on the left-hand side of a
binding:

[source, clojure]
----
(let [[fst _ thrd] [0 1 2]]
  [thrd fst])
;; => [2 0]
----

In the above example, `[fst _ thrd]` is a destructuring form. It is represented as a
vector and used for binding indexed values to the symbols `fst` and `thrd`,
corresponding to the index `0` and `2`, respectively. The `_` symbol is used as a
placeholder for indexes we are not interested in — in this case `1`.

Note that destructuring is not limited to the `let` binding form; it works in almost
every place where we bind values to symbols such as in the `for` and `doseq` special
forms or in function arguments. We can write a function that takes a pair and swaps
its positions very concisely using destructuring syntax in function arguments:

[source, clojure]
----
(defn swap-pair [[fst snd]]
  [snd fst])

(swap-pair [1 2])
;; => [2 1]

(swap-pair '(3 4))
;; => [4 3]
----

Positional destructuring with vectors is quite handy for taking indexed values out
of sequences, but sometimes we don't want to discard the rest of the elements in the
sequence when destructuring.  Similarly to how `&` is used for accepting variadic
function arguments, the ampersand can be used inside a vector destructuring form for
grouping together the rest of a sequence:

[source, clojure]
----
(let [[fst snd & more] (range 10)]
  {:first fst
   :snd snd
   :rest more})
;; => {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}
----

Notice how the value in the `0` index got bound to `fst`, the value in the `1` index
got bound to `snd`, and the sequence of elements from `2` onwards got bound to the
`more` symbol.

We may still be interested in a data structure as a whole even when we are
destructuring it. This can be achieved with the `:as` keyword. If used inside a
destructuring form, the original data structure is bound to the symbol following
that keyword:

[source, clojure]
----
(let [[fst snd & more :as original] (range 10)]
  {:first fst
   :snd snd
   :rest more
   :original original})
;; => {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}
----

Not only can indexed sequences be destructured, but associative data can also be
destructured. Its destructuring binding form is represented as a map instead of a
vector, where the keys are the symbols we want to bind values to and the values are
the keys that we want to look up in the associative data structure. Let's see an
example:

[source, clojure]
----
(let [{language :language} {:language "ClojureScript"}]
  language)
;; => "ClojureScript"
----

In the above example, we are extracting the value associated with the `:language`
key and binding it to the `language` symbol. When looking up keys that are not
present, the symbol will get bound to `nil`:

[source, clojure]
----
(let [{name :name} {:language "ClojureScript"}]
  name)
;; => nil
----

Associative destructuring lets us give default values to bindings which will be used
if the key isn't found in the data structure we are taking apart. A map following
the `:or` keyword is used for default values as the following examples show:

[source, clojure]
----
(let [{name :name :or {name "Anonymous"}} {:language "ClojureScript"}]
  name)
;; => "Anonymous"

(let [{name :name :or {name "Anonymous"}} {:name "Cirilla"}]
  name)
;; => "Cirilla"
----

Associative destructuring also supports binding the original data structure to a
symbol placed after the `:as` keyword:

[source, clojure]
----
(let [{name :name :as person} {:name "Cirilla" :age 49}]
  [name person])
;; => ["Cirilla" {:name "Cirilla" :age 49}]
----

Keywords aren't the only things that can be the keys of associative data structures.
Numbers, strings, symbols and many other data structures can be used as keys, so we
can destructure using those, too. Note that we need to quote the symbols to prevent
them from being resolved as a var lookup:

[source, clojure]
----
(let [{one 1} {0 "zero" 1 "one"}]
  one)
;; => "one"

(let [{name "name"} {"name" "Cirilla"}]
  name)
;; => "Cirilla"

(let [{lang 'language} {'language "ClojureScript"}]
  lang)
;; => "ClojureScript"
----

Since the values corresponding to keys are usually bound to their equivalent symbol
representation (for example, when binding the value of `:language` to the symbol
`language`) and keys are usually keywords, strings, or symbols, ClojureScript offers
shorthand syntax for these cases.

We'll show examples of all of these, starting with destructuring keywords using
`:keys`:

[source, clojure]
----
(let [{:keys [name surname]} {:name "Cirilla" :surname "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]
----

As you can see in the example, if we use the `:keys` keyword and associate it with a
vector of symbols in a binding form, the values corresponding to the keywordized
version of the symbols will be bound to them. The `{:keys [name surname]}`
destructuring is equivalent to `{name :name surname :surname}`, only shorter.

The string and symbol shorthand syntax works exactly like `:keys`, but using the
`:strs` and `:syms` keywords respectively:

[source, clojure]
----
(let [{:strs [name surname]} {"name" "Cirilla" "surname" "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]

(let [{:syms [name surname]} {'name "Cirilla" 'surname "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]
----

An interesting property of destructuring is that we can nest destructuring forms
arbitrarily, which makes code that accesses nested data on a collection very easy to
understand, as it mimics the collection's structure:

[source, clojure]
----
(let [{[fst snd] :languages} {:languages ["ClojureScript" "Clojure"]}]
  [snd fst])
;; => ["Clojure" "ClojureScript"]
----


=== Threading Macros

Threading macros, also known as arrow functions, enables one to write more readable code
when multiple nested function calls are performed.

Imagine you have `(f (g (h x)))` where a function `f` receives as its first parameter the
result of executing function `g`, repeated multiple times. With the most basic `->` threading
macro you can convert that into `(\-> x (h) (g) (f))` which is easier to read.

The result is syntactic sugar, because the arrow functions are defined as macros
and it does not imply any runtime performance. The `(\-> x (h) (g) (f))` is
automatically converted to (f (g (h x))) at compile time.

Take note that the parenthesis on `h`, `g` and `f` are optional, and can be ommited:
`(f (g (h x)))` is the same as `(\-> x h g f)`.


==== The thread-first macro (`\->`)

This is called *thread first* because it threads the first argument throught the
different expressions as first arguments.

Using a more concrete example, this is how the code looks without using threading
macros:

[source, clojure]
----
(def book {:name "Lady of the Lake"
           :readers 0})

(update (assoc book :age 1999) :readers inc)
;; => {:name "Lady of the lake" :age 1999 :readers 1}
----

We can rewrite that code to use the `\->` threading macro:

[source, clojure]
----
(-> book
    (assoc :age 1999)
    (update :readers inc))
;; => {:name "Lady of the lake" :age 1999 :readers 1}
----

This threading macro is especially useful for transforming data structures, because
_ClojureScript_ (and _Clojure_) functions for data structures transformations
consistently uses the first argument for receive the data structure.


==== The thread-last macro (`\->>`)

The main difference between the thread-last and thread-first macros is that instead
of threading the first argument given as the first argument on the following expresions,
it threads it as the last argument.

Let's look at an example:

[source, clojure]
----
(def numbers [1 2 3 4 5 6 7 8 9 0])

(take 2 (filter odd? (map inc numbers)))
;; => (3 5)
----

The same code written using `\->>` threading macro:

[source, clojure]
----
(->> numbers
     (map inc)
     (filter odd?)
     (take 2))
;; => (3 5)
----

This threading macro is especially useful for transforming sequences or collections
of data because _ClojureScript_ functions that work with sequences and collections
consistently use the last argument position to receive them.


==== The thread-as macro (`as\->`)

Finally, there are cases where neither `\->` nor `\->>` are applicable. In these
cases, you’ll need to use `as\->`, the more flexible alternative, that allows you to
thread into any argument position, not just the first or last.

It expects two fixed arguments and an arbitrary number of expressions. As with
`\->`, the first argument is a value to be threaded through the following forms. The
second argument is the name of a binding. In each of the subsequent forms, the bound
name can be used for the prior expression's result.

Let's see an example:

[source, clojure]
----
(as-> numbers $
  (map inc $)
  (filter odd? $)
  (first $)
  (hash-map :result $ :id 1))
;; => {:result 3 :id 1}
----


==== The thread-some macros (`some\->` and `some\->>`)

Two of the more specialized threading macros that _ClojureScript_ comes with. They work
in the same way as their analagous `\->` and `\->>` macros with the additional
support for short-circuiting the expression if one of the expresions evaluates
to `nil`.

Let's see another example:

[source, clojure]
----
(some-> (rand-nth [1 nil])
        (inc))
;; => 2

(some-> (rand-nth [1 nil])
        (inc))
;; => nil
----

This is an easy way avoid null pointer exceptions.


==== The thread-cond macros (`cond\->` and `cond\->>`)

The `cond\->` and `cond\->>` macros are analogous to `\->` and `\->>` that offers
the ability to conditionally skip some steps from the pipeline. Let see an example:

[source, clojure]
----
(defn describe-number
  [n]
  (cond-> []
    (odd? n) (conj "odd")
    (even? n) (conj "even")
    (zero? n) (conj "zero")
    (pos? n) (conj "positive")))

(describe-number 3)
;; => ["odd" "positive"]

(describe-number 4)
;; => ["even" "positive"]
----

The value threading only happens when the corresponding condition evaluates to
logical true.

==== Additional Readings

- http://www.spacjer.com/blog/2015/11/09/lesser-known-clojure-variants-of-threading-macro/
- http://clojure.org/guides/threading_macros


[[reader-conditionals]]
=== Reader Conditionals

This language feature allows different dialects of Clojure to share common code that
is mostly platform independent but need some platform dependent code.

To use reader conditionals, all you need is to rename your source file with
`.cljs` extension to one with `.cljc`, because reader conditionals only work if
they are placed in files with `.cljc` extension.

==== Standard (`#?`)

There are two types of reader conditionals, standard and splicing. The standard
reader conditional behaves similarly to a traditional cond and the syntax looks
like this:

[source, clojure]
----
(defn parse-int
  [v]
  #?(:clj  (Integer/parseInt v)
     :cljs (js/parseInt v)))
----

As you can observe, `#?` reading macro looks very similar to cond, the difference is
that the condition is just a keyword that identifies the platform, where `:cljs` is
for _ClojureScript_ and `:clj` is for _Clojure_. The advantage of this approach, is
that it is evaluated at compile time so no runtime performance overhead exists for
using this.

==== Splicing (`#?@`)

The splicing reader conditional works in the same way as the standard and allows
splice lists into the containing form. The `#?@` reader macro is used for that
and the code looks like this:

[source, clojure]
----
(defn make-list
  []
  (list #?@(:clj  [5 6 7 8]
            :cljs [1 2 3 4])))

;; On ClojureScript
(make-list)
;; => (1 2 3 4)
----

The _ClojureScript_ compiler will read that code as this:

[source, clojure]
----
(defn make-list
  []
  (list 1 2 3 4))
----

The splicing reader conditional can't be used to splice multiple top level forms,
so the following code is ilegal:

[source, clojure]
----
#?@(:cljs [(defn func-a [] :a)
           (defn func-b [] :b)])
;; => #error "Reader conditional splicing not allowed at the top level."
----

If you need so, you can use multiple forms or just use `do` block for group
multiple forms together:

[source, clojure]
----
#?(:cljs (defn func-a [] :a))
#?(:cljs (defn func-b [] :b))

;; Or

#?(:cljs
   (do
     (defn func-a [] :a)
     (defn func-b [] :b)))
----


==== More readings

- http://clojure.org/guides/reader_conditionals
- https://danielcompton.net/2015/06/10/clojure-reader-conditionals-by-example
- https://github.com/funcool/cuerdas (example small project that uses
  reader conditionals)

[[namespace-section]]
=== Namespaces

==== Defining a namespace

The _namespace_ is ClojureScript's fundamental unit of code modularity. Namespaces
are analogous to Java packages or Ruby and Python modules and can be defined with
the `ns` macro. If you have ever looked at a little bit of ClojureScript source, you
may have noticed something like this at the beginning of the file:

[source, clojure]
----
(ns myapp.core
  "Some docstring for the namespace.")

(def x "hello")
----

Namespaces are dynamic, meaning you can create one at any time. However, the
convention is to have one namespace per file. Naturally, a namespace definition is
usually at the beginning of the file, followed by an optional docstring.

Previously we have explained vars and symbols. Every var that you define will be
associated with its namespace. If you do not define a concrete namespace, then the
default one called "cljs.user" will be used:

[source, clojure]
----
(def x "hello")
;; => #'cljs.user/x
----


==== Loading other namespaces

Defining a namespace and the vars in it is really easy, but it's not very useful if
we can't use symbols from other namespaces. For this purpose, the `ns` macro offers
a simple way to load other namespaces.

Observe the following:

[source, clojure]
----
(ns myapp.main
  (:require myapp.core
            clojure.string))

(clojure.string/upper-case myapp.core/x)
;; => "HELLO"
----

As you can observe, we are using fully qualified names (namespace + var name) for
access to vars and functions from different namespaces.

While this will let you access other namespaces, it's also repetitive and overly
verbose. It will be especially uncomfortable if the name of a namespace is very
long. To solve that, you can use the `:as` directive to create an additional
(usually shorter) alias to the namespace.  This is how it can be done:

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))

(str/upper-case core/x)
;; => "HELLO"
----

Additionally, _ClojureScript_ offers a simple way to refer to specific vars or
functions from a concrete namespace using the `:refer` directive, followed by a
sequence of symbols that will refer to vars in the namespace. Effectively, it is as
if those vars and functions are now part of your namespace, and you do not need to
qualify them at all.

[source, clojure]
----
(ns myapp.main
  (:require [clojure.string :refer [upper-case]]))
(upper-case x)
;; => "HELLO"
----

And finally, you should know that everything located in the `cljs.core` namespace is
automatically loaded and you should not require it explicitly. Sometimes you may
want to declare vars that will clash with some others defined in the `cljs.core`
namespace. To do this, the `ns` macro offers another directive that allows you to
exclude specific symbols and prevent them from being automatically loaded.

Observe the following:

[source, clojure]
----
(ns myapp.main
  (:refer-clojure :exclude [min]))

(defn min
  [x y]
  (if (> x y)
    y
    x))
----

The `ns` macro also has other directives for loading host classes (with `:import`)
and macros (with `:refer-macros`), but these are explained in other sections.


==== Namespaces and File Names

When you have a namespace like `myapp.core`, the code must be in a file named
_core.cljs_ inside the _myapp_ directory.  So, the preceding examples with
namespaces `myapp.core` and `myapp.main` would be found in project with a file
structure like this:

----
myapp
└── src
    └── myapp
        ├── core.cljs
        └── main.cljs
----


=== Abstractions and Polymorphism

I'm sure that at more than one time you have found yourself in this situation: you
have defined a great abstraction (using interfaces or something similar) for your
"business logic", and you have found the need to deal with another module over which
you have absolutely no control, and you probably were thinking of creating adapters,
proxies, and other approaches that imply a great amount of additional complexity.

Some dynamic languages allow "monkey-patching"; languages where the classes are open
and any method can be defined and redefined at any time. Also, it is well known that
this technique is a very bad practice.

We can not trust languages that allow you to silently overwrite methods that you are
using when you import third party libraries; you cannot expect consistent behavior
when this happens.

These symptoms are commonly called the "expression problem";
see http://en.wikipedia.org/wiki/Expression_problem for more details


==== Protocols

The _ClojureScript_ primitive for defining "interfaces" is called a protocol. A
protocol consists of a name and set of functions. All the functions have at least
one argument corresponding to the `this` in JavaScript or `self` in Python.

Protocols provide a type-based polymorphism, and the dispatch is always done by the
first argument (equivalent to JavaScript’s `this`, as previously mentioned).

A protocol looks like this:

[source, clojure]
----
(ns myapp.testproto)

(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string associated with this function."))
----

NOTE: the "I" prefix is commonly used to designate the separation of protocols and
types. In the Clojure community, there are many different opinions about how the "I"
prefix should be used. In our opinion, it is an acceptable solution to avoid name
clashing and possible confusion. But not using the prefix is not considered bad
practice.

From the user perspective, protocol functions are simply plain functions defined in
the namespace where the protocol is defined. This enables an easy and simple aproach
for avoid conflicts between different protocols implemented for the same type that
have conflicting function names.

Here is an example. Let's create a protocol called `IInvertible` for data that can
be "inverted".  It will have a single method named `invert`.

[source, clojure]
----
(defprotocol IInvertible
  "This is a protocol for data types that are 'invertible'"
  (invert [this] "Invert the given item."))
----


===== Extending existing types

One of the big strengths of protocols is the ability to extend existing and maybe
third party types. This operation can be done in different ways.

The majority of time you will tend to use the *extend-protocol* or the *extend-type*
macros. This is how `extend-type` syntax looks:

[source, clojure]
----
(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  ProtocolB
  (function-from-protocol-b-1 [this parameter1]
    ;; implementation here
    )
  (function-from-protocol-b-2 [this parameter1 parameter2]
    ;; implementation here
    ))
----

You can observe that with *extend-type* you are extending a single type with
different protocols in a single expression.

Let's play with our `IInvertible` protocol defined previously:

[source, clojure]
----
(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))

(extend-type cljs.core.List
  IInvertible
  (invert [this] (reverse this)))

(extend-type cljs.core.PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))
----

You may note that a special symbol *string* is used instead of `js/String` for
extend the protol for string. This is because the builtin javascript types have
special treatment and if you replace the `string` with `js/String` the compiler
will emit a warning about that.

So if you want extend your protocol to javascript primitive types, instead of using
`js/Number`, `js/String`, `js/Object`, `js/Array`, `js/Boolean` and `js/Function`
you should use the respective special symbols: `number`, `string`, `object`,
`array`, `boolean` and `function`.

Now, it's time to try our protocol implementation:

[source, clojure]
----
(invert "abc")
;; => "cba"

(invert 0)
;; => 0

(invert '(1 2 3))
;; => (3 2 1)

(invert [1 2 3])
;; => [3 2 1]
----

In comparison, *extend-protocol* does the inverse; given a protocol, it adds
implementations for multiple types. This is how the syntax looks:

[source, clojure]
----
(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  TypeB
  (function-from-protocol-a [this]
    ;; implementation here
    ))
----

Thus, the previous example could have been written equally well with this way:

[source, clojure]
----
(extend-protocol IInvertible
  string
  (invert [this] (apply str (reverse this)))

  cljs.core.List
  (invert [this] (reverse this))

  cljs.core.PersistentVector
  (invert [this] (into [] (reverse this))))
----


===== Participate in ClojureScript abstractions

ClojureScript itself is built up on abstractions defined as protocols. Almost all
behavior in the _ClojureScript_ language itself can be adapted to third party
libraries. Let's look at a real life example.

In previous sections, we have explained the different kinds of built-in
collections. For this example we will use a *set*. See this snippet of code:

[source, clojure]
----
(def mynums #{1 2})

(filter mynums [1 2 4 5 1 3 4 5])
;; => (1 2 1)
----

What happened? In this case, the _set_ type implements the _ClojureScript_ internal
`IFn` protocol that represents an abstraction for functions or anything
callable. This way it can be used like a callable predicate in filter.

OK, but what happens if we want to use a regular expression as a predicate function
for filtering a collection of strings:

[source, clojure]
----
(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined
----

The exception is raised because the `RegExp` type does not implement the `IFn`
protocol so it cannot behave like a callable, but that can be easily fixed:

[source, clojure]
----
(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))
----

Let’s analyze this: we are extending the `js/RegExp` type so that it implements the
`invoke` function in the `IFn` protocol. To invoke a regular expression `a` as if it
were a function, call the `re-find` function with the object of the function and the
pattern.

Now, you will be able use the regex instances as predicates in a filter operation:

[source, clojure]
----
(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; => ("foobar" "foobaz")
----


===== Introspection using Protocols

_ClojureScript_ comes with a useful function that allows runtime introspection:
`satisfies?`. The purpose of this function is to determine at runtime if some object
(instance of some type) satisfies the concrete protocol.

So, with the previous examples, if we check if a `set` instance satisfies an *IFn*
protocol, it should return `true`:

[source, clojure]
----
(satisfies? IFn #{1})
;; => true
----


==== Multimethods

We have previously talked about protocols which solve a very common use case of
polymorphism: dispatch by type. But in some circumstances, the protocol approach can
be limiting. And here, *multimethods* come to the rescue.

These *multimethods* are not limited to type dispatch only; instead, they also offer
dispatch by types of multiple arguments and by value. They also allow ad-hoc
hierarchies to be defined. Also, like protocols, multimethods are an "Open System",
so you or any third parties can extend a multimethod for new types.

The basic constructions of *multimethods* are the `defmulti` and `defmethod`
forms. The `defmulti` form is used to create the multimethod with an initial
dispatch function. This is a model of what it looks like:

[source, clojure]
----
(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)
----

The anonymous function defined within the `defmulti` form is a dispatch function. It
will be called in every call to the `say-hello` function and should return some kind
of marker object that will be used for dispatch. In our example, it returns the
contents of the `:locale` key of the first argument.

And finally, you should add implementations. That is done with the `defmethod` form:

[source, clojure]
----
(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))

(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anónimo")))
----

So, if you execute that function over a hash map containing the `:locale` and
optionally the `:name` key, the multimethod will first call the dispatch function to
determine the dispatch value, then it will search for an implementation for that
value. If an implementation is found, the dispatcher will execute it. Otherwise, the
dispatch will search for a default implementation (if one is specified) and execute
it.

[source, clojure]
----
(say-hello {:locale :es})
;; => "Hola Anónimo"

(say-hello {:locale :en :name "Ciri"})
;; => "Hello Ciri"

(say-hello {:locale :fr})
;; => "Hello Anonymous"
----

If the default implementation is not specified, an exception will be raised
notifying you that some value does not have an implementation for that multimethod.


==== Hierarchies

Hierarchies are _ClojureScript_’s way to let you build whatever relations that your
domain may require. Hierarchies are defined in term of relations between named
objects, such as symbols, keywords, or types.

Hierarchies can be defined globally or locally, depending on your needs. Like
multimethods, hierarchies are not limited to a single namespace. You can extend a
hierarchy from any namespace, not only from the one in which it is defined.

The global namespace is more limited, for good reasons. Keywords or symbols that are
not namespaced can not be used in the global hierarchy. That behavior helps prevent
unexpected situations when two or more third party libraries use the same symbol for
different semantics.


===== Defining a hierarchy

The hierarchy relations should be established using the `derive` function:

[source, clojure]
----
(derive ::circle ::shape)
(derive ::box ::shape)
----

We have just defined a set of relationships between namespaced keywords. In this
case the `::circle` is a child of `::shape`, and `::box` is also a child of
`::shape`.

TIP: The `::circle` keyword syntax is a shorthand for `:current.ns/circle`. So if
you are executing it in a REPL, `::circle` will be evaluated as `:cljs.user/circle`.


===== Hierarchies and introspection

_ClojureScript_ comes with a little toolset of functions that allows runtime
introspection of globally or locally defined hierarchies. This toolset consists of
three functions: `isa?`, `ancestors`, and `descendants`.

Let's see an example of how it can be used with the hierarchy defined in the
previous example:

[source, clojure]
----
(ancestors ::box)
;; => #{:cljs.user/shape}

(descendants ::shape)
;; => #{:cljs.user/circle :cljs.user/box}

(isa? ::box ::shape)
;; => true

(isa? ::rect ::shape)
;; => false
----


===== Locally defined hierarchies

As we mentioned previously, in _ClojureScript_ you also can define local
hierarchies. This can be done with the `make-hierarchy` function. Here is an example
of how you can replicate the previous example using a local hierarchy:

[source, clojure]
----
(def h (-> (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))
----

Now you can use the same introspection functions with that locally defined
hierarchy:

[source, clojure]
----
(isa? h :box :shape)
;; => true

(isa? :box :shape)
;; => false
----

As you can observe, in local hierarchies we can use normal (not namespace qualified)
keywords, and if we execute the `isa?` without passing the local hierarchy
parameter, it returns `false` as expected.


===== Hierarchies in multimethods

One of the big advantages of hierarchies is that they work very well together with
multimethods.  This is because multimethods by default use the `isa?` function for
the last step of dispatching.

Let's see an example to clearly understand what that means. First, we define the
multimethod with the `defmulti` form:

[source, clojure]
----
(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy #'h)
----

With the `:hierarchy` keyword parameter, we indicate to the multimethod what
hierarchy we want to use; if it is not specified, the global hierarchy will be used.

Second, we define an implementation for our multimethod using the `defmethod` form:

[source, clojure]
----
(defmethod stringify-shape :box
  [_]
  "A box shape")

(defmethod stringify-shape :shape
  [_]
  "A generic shape")

(defmethod stringify-shape :default
  [_]
  "Unexpected object")
----

Now, let's see what happens if we execute that function with a box:

[source, clojure]
----
(stringify-shape :box)
;; => "A box shape"
----

Now everything works as expected; the multimethod executes the direct matching
implementation for the given parameter. Next, let's see what happens if we execute
the same function but with the `:circle` keyword as the parameter which does not
have the direct matching dispatch value:

[source, clojure]
----
(stringify-shape :circle)
;; => "A generic shape"
----

The multimethod automatically resolves it using the provided hierarchy, and since
`:circle` is a descendant of `:shape`, the `:shape` implementation is executed.

Finally, if you give a keyword that isn't part of the hierarchy, you get the
`:default` implementation:

[source,clojure]
----
(stringify-shape :triangle)
;; => "Unexpected object"
----


=== Data types

Until now, we have used maps, sets, lists, and vectors to represent our data. And in
most cases, this is a really great approach. But sometimes we need to define our own
types, and in this book we will call them *data types*.

A data type provides the following:

* A unique host-backed type, either named or anonymous.
* The ability to implement protocols (inline).
* Explicitly declared structure using fields or closures.
* Map-like behavior (via records, see below).


==== Deftype

The most low-level construction in _ClojureScript_ for creating your own types is
the `deftype` macro. As a demonstration, we will define a type called `User`:

[source, clojure]
----
(deftype User [firstname lastname])
----

Once the type has been defined, we can create an instance of our `User`. In the
following example, the `.` after `User` indicates that we are calling a constructor.

[source, clojure]
----
(def person (User. "Triss" "Merigold"))
----

Its fields can be accessed using the prefix dot notation:

[source, clojure]
----
(.-firstname person)
;; => "Triss"
----

Types defined with `deftype` (and `defrecord`, which we will see later) create a
host-backed class-like object associated with the current namespace. For
convenience, _ClojureScript_ also defines a constructor function called `->User`
that can be imported using the `:require` directive.

We personally do not like this type of function, and we prefer to define our own
constructors with more idiomatic names:

[source, clojure]
----
(defn make-user
  [firstname lastname]
  (User. firstname lastname))
----

We use this in our code instead of `->User`.


==== Defrecord

The record is a slightly higher-level abstraction for defining types in
_ClojureScript_ and should be the preferred way to do it.

As we know, _ClojureScript_ tends to use plain data types such as maps, but in most
cases we need a named type to represent the entities of our application. Here come
the records.

A record is a data type that implements the map protocol and therefore can be used
like any other map.  And since records are also proper types, they support
type-based polymorphism through protocols.

In summary: with records, we have the best of both worlds, maps that can play in
different abstractions.

Let's start defining the `User` type but using records:

[source, clojure]
----
(defrecord User [firstname lastname])
----

It looks really similar to the `deftype` syntax; in fact, it uses `deftype` behind
the scenes as a low-level primitive for defining types.

Now, look at the difference with raw types for access to its fields:

[source, clojure]
----
(def person (User. "Yennefer" "of Vengerberg"))

(:firstname person)
;; => "Yennefer"

(get person :firstname)
;; => "Yennefer"
----

As we mentioned previously, records are maps and act like them:

[source, clojure]
----
(map? person)
;; => true
----

And like maps, they support extra fields that are not initially defined:

[source, clojure]
----
(def person2 (assoc person :age 92))

(:age person2)
;; => 92
----

As we can see, the `assoc` function works as expected and returns a new instance of
the same type but with new key value pair. But take care with `dissoc`! Its behavior
with records is slightly different than with maps; it will return a new record if
the field being dissociated is an optional field, but it will return a plain map if
you dissociate a mandatory field.

Another difference with maps is that records do not act like functions:

[source, clojure]
----
(def plain-person {:firstname "Yennefer", :lastname "of Vengerberg"})

(plain-person :firstname)
;; => "Yennefer"

(person :firstname)
;; => person.User does not implement IFn protocol.
----

For convenience, the `defrecord` macro, like `deftype`, exposes a `->User` function,
as well as an additional `map->User` constructor function. We have the same opinion
about that constructor as with `deftype` defined ones: we recommend defining your
own instead of using the other ones. But as they exist, let’s see how they can be
used:

[source, clojure]
----
(def cirilla (->User "Cirilla" "Fiona"))
(def yen (map->User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))
----


==== Implementing protocols

Both type definition primitives that we have seen so far allow inline
implementations for protocols (explained in a previous section). Let's define one
for example purposes:

[source, clojure]
----
(defprotocol IUser
  "A common abstraction for working with user types."
  (full-name [_] "Get the full name of the user."))
----

Now, you can define a type with inline implementation for an abstraction, in our
case the `IUser`:

[source, clojure]
----
(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))

;; Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))

(full-name user)
;; => "Yennefer of Vengerberg"
----


==== Reify

The `reify` macro is an _ad hoc constructor_ you can use to create objects without
pre-defining a type.  Protocol implementations are supplied the same as `deftype`
and `defrecord`, but in contrast, `reify` does not have accessible fields.

This is how we can emulate an instance of the user type that plays well with the
`IUser` abstraction:

[source, clojure]
----
(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))

(def yen (user "Yennefer" "of Vengerberg"))
(full-name yen)
;; => "Yennefer of Vengerberg"
----

==== Specify

`specify!` is an advanced alternative to `reify`, allowing you to add protocol
implementations to an existing JavaScript object.  This can be useful if you want to
graft protocols onto a JavaScript library's components.

[source, clojure]
----
(def obj #js {})

(specify! obj
  IUser
  (full-name [_]
    "my full name"))

(full-name obj)
;; => "my full name"
----

`specify` is an immutable version of `specify!` that can be used on immutable,
copyable values implementing `ICloneable` (e.g. ClojureScript collections).

[source, clojure]
----
(def a {})

(def b (specify a
         IUser
         (full-name [_]
           "my full name")))

(full-name a)
;; Error: No protocol method IUser.full-name defined for type cljs.core/PersistentArrayMap: {}

(full-name b)
;; => "my full name"
----


=== Host interoperability

_ClojureScript_, in the same way as its brother Clojure, is designed to be a "guest"
language. This means that the design of the language works well on top of an
existing ecosystem such as JavaScript for _ClojureScript_ and the JVM for _Clojure_.


==== The types

_ClojureScript_, unlike what you might expect, tries to take advantage of every type
that the platform provides. This is a (perhaps incomplete) list of things that
_ClojureScript_ inherits and reuses from the underlying platform:

* _ClojureScript_ strings are JavaScript *Strings*.
* _ClojureScript_ numbers are JavaScript *Numbers*.
* _ClojureScript_ `nil` is a JavaScript *null*.
* _ClojureScript_ regular expressions are JavaScript `RegExp` instances.
* _ClojureScript_ is not interpreted; it is always compiled down to JavaScript.
* _ClojureScript_ allows easy call to platform APIs with the same semantics.
* _ClojureScript_ data types internally compile to objects in JavaScript.

On top of it, _ClojureScript_ builds its own abstractions and types that do not
exist in the platform, such as Vectors, Maps, Sets, and others that are explained in
preceding sections of this chapter.


==== Interacting with platform types

_ClojureScript_ comes with a little set of special forms that allows it to interact
with platform types such as calling object methods, creating new instances, and
accessing object properties.


===== Access to the platform

_ClojureScript_ has a special syntax for access to the entire platform environment
through the `js/` special namespace. This is an example of an expression to execute
JavaScript's built-in `parseInt` function:

[source, clojure]
----
(js/parseInt "222")
;; => 222
----


===== Creating new instances

_ClojureScript_ has two ways to create instances:

Using the `new` special form
[source, clojure]
----
(new js/RegExp "^foo$")
----

Using the `.` special form
[source, clojure]
----
(js/RegExp. "^foo$")
----

The last one is the recommended way to create instances. We are not aware of any
real differences between the two forms, but in the ClojureScript community, the last
one is used most often.


===== Invoke instance methods

To invoke methods of some object instance, as opposed to how it is done in
JavaScript (e.g., `obj.method()`, the method name comes first like any other
standard function in Lisp languages but with a little variation: the function name
starts with special form `.`.

Let's see how we can call the `.test()` method of a regexp instance:

[source, clojure]
----
(def re (js/RegExp "^Clojure"))

(.test re "ClojureScript")
;; => true
----

You can invoke instance methods on JavaScript objects. The first example follows the
pattern you have seen; the last one is a shortcut:

[source,clojure]
----
(.sqrt js/Math 2)
;; => 1.4142135623730951
(js/Math.sqrt 2)
;; => 1.4142135623730951
----


===== Access to object properties

Access to an object's properties is really very similar to calling a method. The
difference is that instead of using the `.` you use `.-`. Let's see an example:

[source, clojure]
----
(.-multiline re)
;; => false
(.-PI js/Math)
;; => 3.141592653589793
----


===== Property access shorthand

Symbols with the `js/` prefix can contain dots to denote nested property access.
Both of the following expressions invoke the same function:

[source, clojure]
----
(.log js/console "Hello World")

(js/console.log "Hello World")
----

And both of the following expressions access the same property:

[source, clojure]
----
(.-PI js/Math)
;; => 3.141592653589793

js/Math.PI
;; => 3.141592653589793
----


===== JavaScript objects

_ClojureScript_ has different ways to create plain JavaScript objects; each one has
its own purpose. The basic one is the `js-obj` function. It accepts a variable
number of pairs of keys and values and returns a JavaScript object:

[source, clojure]
----
(js-obj "country" "FR")
;; => #js {:country "FR"}
----

The return value can be passed to some kind of third party library that accepts a
plain JavaScript object, but you can observe the real representation of the return
value of this function. It is really another form for doing the same thing.

Using the reader macro `#js` consists of prepending it to a ClojureScript map or
vector, and the result will be transformed to plain JavaScript:

[source, clojure]
----
(def myobj #js {:country "FR"})
----

The translation of that to plain JavaScript is similar to this:

[source, javascript]
----
var myobj = {country: "FR"};
----

As explained in the previous section, you can also access the plain object
properties using the `.-` syntax:

[source, clojure]
----
(.-country myobj)
;; => "FR"
----

And as JavaScript objects are mutable, you can set a new value for some property
using the `set!` function:

[source, clojure]
----
(set! (.-country myobj) "KR")
----


===== Conversions

The inconvenience of the previously explained forms is that they do not make
recursive transformations, so if you have nested objects, the nested objects will
not be converted.  Consider this example that uses Clojurescript maps, then a
similar one with JavaScript objects:

[source, clojure]
----
(def clj-map {:country {:code "FR" :name "France"}})
;; => {:country {:code "FR", :name "France"}}
(:code (:country clj-map))
;; => "FR"

(def js-obj #js {:country {:code "FR" :name "France"}})
;; => #js {:country {:code "FR", :name "France"}
(.-country js-obj)
;; => {:code "FR", :name "France"}
(.-code (.-country js-obj)
;; => nil
----

To solve that use case, _ClojureScript_ comes with the `clj->js` and `js->clj`
functions that transform Clojure collection types into JavaScript and back. Note
that the conversion to ClojureScript changes the `:country` keyword to a string.

[source, clojure]
----
(clj->js {:foo {:bar "baz"}})
;; => #js {:foo #js {:bar "baz"}}
(js->clj #js {:country {:code "FR" :name "France"}}))
;; => {"country" {:code "FR", :name "France"}}
----

In the case of arrays, there is a specialized function `into-array` that behaves as
expected:

[source, clojure]
----
(into-array ["France" "Korea" "Peru"])
;; => #js ["France" "Korea" "Peru"]
----


===== Arrays

In the previous example, we saw how we can create an array from an existing
_ClojureScript_ collection. But there is another function for creating arrays:
`make-array`.

.Creating a preallocated array with length 10
[source, clojure]
----
(def a (make-array 10))
;; => #js [nil nil nil nil nil nil nil nil nil nil]
----

In _ClojureScript_, arrays also play well with sequence abstractions, so you can
iterate over them or simply get the number of elements with the `count` function:

[source, clojure]
----
(count a)
;; => 10
----

As arrays in the JavaScript platform are a mutable collection type, you can access a
concrete index and set the value at that position:

[source, clojure]
----
(aset a 0 2)
;; => 2
a
;; => #js [2 nil nil nil nil nil nil nil nil nil]
----

Or access in an indexed way to get its values:

[source, clojure]
----
(aget a 0)
;; => 2
----

In JavaScript, array index access is equivalent to object property access, so you
can use the same functions for interacting with plain objects:

[source, clojure]
----
(def b #js {:hour 16})
;; => #js {:hour 16}

(aget b "hour")
;; => 16

(aset b "minute" 22)
;; => 22

b
;; => #js {:hour 16, :minute 22}
----


=== State management

We've learned that one of ClojureScript's fundamental ideas is immutability. Both
scalar values and collections are immutable in ClojureScript, except those mutable
types present in the JS host like `Date`.

Immutability has many great properties but we are sometimes faced with the need to
model values that change over time. How can we achieve this if we can't change data
structures in place?


==== Vars

Vars can be redefined at will inside a namespace but there is no way to know *when*
they change. The inability to redefine vars from other namespaces is a bit limiting;
also, if we are modifying state, we're probably interested in knowing when it
occurs.


==== Atoms

ClojureScript gives us the `Atom` type, which is an object containing a value that
can be altered at will. Besides altering its value, it also supports observation
through watcher functions that can be attached and detached from it and validation
for ensuring that the value contained in the atom is always valid.

If we were to model an identity corresponding to a person called Ciri, we could wrap
an immutable value containing Ciri's data in an atom. Note that we can get the
atom's value with the `deref` function or using its shorthand `@` notation:

[source, clojure]
----
(def ciri (atom {:name "Cirilla" :lastname "Fiona" :age 20}))
;; #<Atom: {:name "Cirilla", :lastname "Fiona", :age 20}>

(deref ciri)
;; {:name "Cirilla", :lastname "Fiona", :age 20}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 20}
----

We can use the `swap!` function on an atom to alter its value with a function. Since
Ciri's birthday is today, let's increment her age count:

[source, clojure]
----
(swap! ciri update :age inc)
;; {:name "Cirilla", :lastname "Fiona", :age 21}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 21}
----

The `reset!` functions replaces the value contained in the atom with a new one:

[source, clojure]
----
(reset! ciri {:name "Cirilla", :lastname "Fiona", :age 22})
;; {:name "Cirilla", :lastname "Fiona", :age 22}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 22}
----

===== Observation

We can add and remove watcher functions for atoms. Whenever the atom's value is
changed through a `swap!` or `reset!`, all the atom's watcher functions will be
called. Watchers are added with the `add-watch` function. Notice that each watcher
has a key associated (`:logger` in the example) to it which is later used to remove
the watch from the atom.

[source, clojure]
----
(def a (atom))

(add-watch a :logger (fn [key the-atom old-value new-value]
                       (println "Key:" key "Old:" old-value "New:" new-value)))

(reset! a 42)
;; Key: :logger Old: nil New: 42
;; => 42

(swap! a inc)
;; Key: :logger Old: 42 New: 43
;; => 43

(remove-watch a :logger)
----


==== Volatiles

Volatiles, like atoms, are objects containing a value that can be altered. However,
they don't provide the observation and validation capabilities that atoms
provide. This makes them slightly more performant and a more suitable mutable
container to use inside stateful functions that don't need observation nor
validation.

Their API closely resembles that of atoms. They can be dereferenced to grab the
value they contain and support swapping and resetting with `vswap!` and `vreset!`
respectively:

[source, clojure]
----
(def ciri (volatile! {:name "Cirilla" :lastname "Fiona" :age 20}))
;; #<Volatile: {:name "Cirilla", :lastname "Fiona", :age 20}>

(volatile? ciri)
;; => true

(deref ciri)
;; {:name "Cirilla", :lastname "Fiona", :age 20}

(vswap! ciri update :age inc)
;; {:name "Cirilla", :lastname "Fiona", :age 21}

(vreset! ciri {:name "Cirilla", :lastname "Fiona", :age 22})
;; {:name "Cirilla", :lastname "Fiona", :age 22}
----

Note that another difference with atoms is that the constructor of volatiles uses a
bang at the end. You create volatiles with `volatile!` and atoms with `atom`.
